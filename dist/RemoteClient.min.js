!function(t,e){"object"==typeof exports&&"undefined"!=typeof module?module.exports=e():"function"==typeof define&&define.amd?define(e):t.RemoteClient=e()}(this,function(){"use strict";const t=require("ohm-js").grammar('\n  G {\n\n    factOrPattern\n      = term*\n\n    term\n      = id\n      | word\n      | value\n      | variable\n      | wildcard\n      | hole\n\n    id\n      = "#" alnum*\n\n    value\n      = keyword<"true">   -- true\n      | keyword<"false">  -- false\n      | keyword<"null">   -- null\n      | number\n      | string\n\n    variable\n      = "$" alnum+\n\n    wildcard\n      = "$"\n\n    hole\n      = "_"\n\n    word\n      = (~special any)+  -- nonspace\n      | space+           -- space\n\n    keyword<k>\n      = k ~alnum\n\n    number\n      = float ("e" float)?\n\n    float\n      = integer ("." digit+)?\n\n    integer\n      = ("+" | "-")? digit+\n\n    string\n      = "\\"" (~"\\"" ~"\\n" any)* "\\""\n\n    special\n      = id | value | variable | wildcard | hole | space\n\n  }\n'),e=t.createSemantics().addOperation("parse",{factOrPattern:t=>t.parse(),id:(t,e)=>({id:e.sourceString}),value_true:t=>({value:!0}),value_false:t=>({value:!1}),value_null:t=>({value:null}),variable:(t,e)=>({variable:e.sourceString}),wildcard:t=>({wildcard:!0}),hole:t=>({hole:!0}),word_nonspace(t){return{word:this.sourceString}},word_space:t=>({word:" "}),number(t,e,r){return{value:parseFloat(this.sourceString)}},string(t,e,r){const s=[];let n=0;for(e=e.parse();n<e.length;){let t=e[n++];if("\\"===t&&n<e.length)switch(t=e[n++]){case"n":t="\n";break;case"t":t="\t";break;default:n--}s.push(t)}return{value:s.join("")}},_terminal(){return this.sourceString}});const r=1e3;class s{constructor(t){this._id=t,this._parseCache=new Map,this._asserts=[],this._retracts=[]}assert(t,...e){const r=this._toJSONFactOrPattern(t,...e);this._asserts.push(r)}retract(t,...e){const r=this._toJSONFactOrPattern(t,...e);this._retracts.push(r)}async flushChanges(){throw new Error("subclass responsibility")}async immediatelyAssert(t,...e){this.assert(t,...e),await this.flushChanges()}async immediatelyRetract(t,...e){this.assert(t,...e),await this.flushChanges()}async immediatelyRetractEverythingAbout(t){throw new Error("subclass responsibility")}async immediatelyRetractEverythingAssertedByMe(){throw new Error("subclass responsibility")}async getAllFacts(){throw new Error("subclass responsibility")}_toJSONFactOrPattern(t,...e){if(0===arguments.length)throw new Error("not enough arguments!");if("string"!=typeof t)throw new Error("factOrPatternString must be a string!");let r=this._parse(t);e.length>0&&(r=r.slice());for(let t=0;t<r.length;t++){if(r[t].hasOwnProperty("hole")){if(0===e.length)throw new Error("not enough filler values!");r[t]=this._toJSONTerm(e.shift())}}if(e.length>0)throw new Error("too many filler values!");return r}_toJSONTerm(t){return{value:t}}_parse(r){if(this._parseCache.has(r))return this._parseCache.get(r);{this._clearParseCacheIfTooBig();const s=function(r,s){const n=s||"factOrPattern",a=t.match(r.trim(),n);if(a.succeeded())return e(a).parse();throw new Error(`invalid ${n}: ${r}`)}(r);return this._parseCache.set(r,s),s}}_clearParseCacheIfTooBig(){this._parseCache.size>r&&this.clearParseCache()}clearParseCache(){this._parseCache.clear()}}class n{toString(){throw new Error("subclass responsibility")}toJSON(){throw new Error("subclass responsibility")}toRawValue(){throw new Error("subclass responsibility")}match(t,e){throw new Error("subclass responsibility")}}n.fromJSON=(t=>{if(t.hasOwnProperty("id"))return new a(t.id);if(t.hasOwnProperty("word"))return new i(t.word);if(t.hasOwnProperty("value"))return new o(t.value);if(t.hasOwnProperty("blobRef"))return new l(t.blobRef);if(t.hasOwnProperty("variable"))return new class extends n{constructor(t){super(),this.name=t}toString(){return"$"+this.name}toJSON(){return{variable:this.name}}toRawValue(){throw new Error("Variable's toRawValue() should never be called!")}match(t,e){return void 0===e[this.name]?(e[this.name]=t,e):e[this.name].match(t,e)}}(t.variable);if(t.hasOwnProperty("wildcard"))return new class extends n{constructor(){super()}toString(){return"$"}toJSON(){return{wildcard:!0}}toRawValue(){throw new Error("Wildcard's toRawValue() should never be called!")}match(t,e){return e}};if(t.hasOwnProperty("hole"))return new class extends n{constructor(){super()}toString(){return"_"}toJSON(){return{hole:!0}}toRawValue(){throw new Error("Hole's toRawValue() should never be called!")}match(t,e){throw new Error("Hole's match() should never be called!")}};throw new Error("unrecognized JSON term: "+JSON.stringify(t))});class a extends n{constructor(t){super(),this.name=t}toString(){return"#"+this.name}toJSON(){return{id:this.name}}toRawValue(){return this}match(t,e){return t instanceof a&&this.name===t.name?e:null}}class i extends n{constructor(t){super(),this.value=t}toString(){return this.value}toJSON(){return{word:this.value}}toRawValue(){return this}match(t,e){return t instanceof i&&this.value===t.value?e:null}}class o extends n{constructor(t){super(),this.value=t}toString(){return JSON.stringify(this.value)}toJSON(){return{value:this.value}}toRawValue(){return this.value}match(t,e){return t instanceof o&&this.value===t.value?e:null}}class l extends n{constructor(t){super(),this.id=t}toString(){return"@"+this.id}toJSON(){return{blobRef:this.id}}toRawValue(){return this}match(t,e){return t instanceof l&&this.id===t.id?e:null}}const h=(()=>{try{return h}catch(t){return require("node-fetch")}})();class c extends s{constructor(t,e,r){super(r),this._address=t,this._port=e}select(...t){const e=t.map(t=>t instanceof Array?this._toJSONFactOrPattern(...t):this._toJSONFactOrPattern(t)),r=async()=>{const t=`query=${JSON.stringify(e)}`,r=await h(`http://${this._address}:${this._port}/facts?${t}`);return await r.json()},s={async do(t){for(let e of await r()){for(let t in e){const r=JSON.parse(JSON.stringify(e[t]));e[t]=n.fromJSON(r).toRawValue()}await t(e)}return s},count:async()=>(await r()).length,isEmpty:async()=>0===(await r()).length,isNotEmpty:async()=>(await r()).length>0};return s}async flushChanges(){const t=this._retracts,e=this._asserts;this._retracts=[],this._asserts=[];const r="clientId="+this._id+"&retractions="+JSON.stringify(t)+"&assertions="+JSON.stringify(e),s=await h(`http://${this._address}:${this._port}/facts?${r}`,{method:"PUT"});return await s.json()}async immediatelyRetractEverythingAbout(t){const e=await h(`http://${this._address}:${this._port}/facts?clientId=${this._id}&name=${t}`,{method:"DELETE"});return await e.json()}async immediatelyRetractEverythingAssertedByMe(){const t=await h(`http://${this._address}:${this._port}/facts?clientId=${this._id}`,{method:"DELETE"});return await t.json()}async getAllFacts(){const t=await h(`http://${this._address}:${this._port}/facts`);return await t.json()}toString(){return`[RemoteClient ${this._address}:${this._port}, ${this._id}]`}}return module.exports=c,c});
//# sourceMappingURL=RemoteClient.min.js.map
