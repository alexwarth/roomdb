!function(t,e){"object"==typeof exports&&"undefined"!=typeof module?module.exports=e():"function"==typeof define&&define.amd?define(e):t.room=e()}(this,function(){"use strict";class t{toRawValue(){return this}}class e extends t{constructor(t){super(),this.value=t}match(t,r){return t instanceof e&&this.value===t.value?r:null}toRawValue(){return this.value}toString(){return JSON.stringify(this.value)}}class r extends t{constructor(t){super(),this.value=t}match(t,e){return t instanceof r&&this.value===t.value?e:null}toRawValue(){return this.value}toString(){return"@"}}class n extends t{constructor(t){super(),this.name=t}match(t,e){return void 0===e[this.name]?(e[this.name]=t,e):e[this.name].match(t,e)}toRawValue(){throw new Error("vars should never show up in a solution!")}toString(){return"$"+this.name}}class s extends t{match(t,e){throw new Error("holes should never show up in a query pattern")}toRawValue(){throw new Error("holes should never show up in a solution!")}toString(){return"_"}}class a extends t{constructor(t){super(),this.name=t}match(t,e){return t instanceof a&&this.name===t.name?e:null}toString(){return"#"+this.name}}class i extends t{constructor(t){super(),this.str=t}match(t,e){return t instanceof i&&this.str===t.str?e:null}toString(){return this.str}}class o{constructor(t){this.terms=t}hasVars(){return this.terms.some(t=>t instanceof n)}match(t,e){if(this.terms.length!==t.terms.length)return null;for(let r=0;r<this.terms.length;r++){const n=this.terms[r],s=t.terms[r];if(!n.match(s,e))return null}return e}toString(){return this.terms.map(t=>t.toString()).join("")}clone(){return new o(this.terms.slice())}}const c=require("ohm-js").grammar('\n  G {\n\n    factOrPattern\n      = term*\n\n    term\n      = keyword<"true">   -- true\n      | keyword<"false">  -- false\n      | keyword<"null">   -- null\n      | space+            -- spaces\n      | var\n      | hole\n      | identity\n      | number\n      | string\n      | word\n\n    keyword<k>\n      = k ~alnum\n\n    var\n      = "$" alnum*\n\n    hole\n      = "_"\n\n    identity\n      = "#" alnum*\n\n    number\n      = float ("e" float)?\n\n    float\n      = integer ("." digit+)?\n\n    integer\n      = ("+" | "-")? digit+\n\n    string\n      = "\\"" (~"\\"" ~"\\n" any)* "\\""\n\n    word\n      = (~special any)+\n\n    special\n      = var | hole | identity | number | space\n\n  }\n'),h=c.createSemantics().addOperation("parse",{factOrPattern:t=>new o(t.parse()),term_true:t=>new e(!0),term_false:t=>new e(!1),term_null:t=>new e(null),var:(t,e)=>new n(e.sourceString),hole:t=>new s,identity:(t,e)=>new a(e.sourceString),number(t,r,n){return new e(parseFloat(this.sourceString))},string(t,r,n){const s=[];let a=0;for(r=r.parse();a<r.length;){let t=r[a++];if("\\"===t&&a<r.length)switch(t=r[a++]){case"n":t="\n";break;case"t":t="\t";break;default:a--}s.push(t)}return new e(s.join(""))},word(t){return new i(this.sourceString)},term_spaces:t=>new i(" "),_terminal(){return this.sourceString}});function l(t,e){const r=c.match(t.trim(),e);if(r.failed())throw new Error(`invalid ${e}: ${t}`);return h(r).parse()}class u{constructor(){this._parseCache=new Map,this._factMap=new Map,this._nextClientId=1,this._clientMap=new Map,this.parse=l}connect(t){if(null===t&&(t=this._newClientId()),this._clientMap.has(t))throw new Error("there is already a client whose id is "+t);const e=new f(t,this);return this._clientMap.set(t,e),e}_newClientId(){return"_"+this._nextClientId++}_select(...t){t=t.map(t=>t instanceof Array?this._makeFactOrPattern(...t):this._makeFactOrPattern(t));const e=[];return this._collectSolutions(t,Object.create(null),e),{do(t){for(let r of e){for(let t in r)r[t]=r[t].toRawValue();t(r)}},doAll(t){let e=[];this.do(t=>e.push(t)),t(e)},count:()=>e.length,isEmpty:()=>0===e.length,isNotEmpty:()=>e.length>0}}_collectSolutions(t,e,r){if(0===t.length)r.push(e);else{const n=t[0];for(let s of this.facts){const a=Object.create(e);n.match(s,a)&&this._collectSolutions(t.slice(1),a,r)}}}_assert(t,e,...r){const n=this._makeFactOrPattern(e,...r);if(n.asserter=t,n.hasVars())throw new Error("cannot assert a fact that has vars!");return n.evidence=[],this._factMap.set(n.toString(),n),{withEvidence:(...t)=>{const e=(t=t.map(t=>this._makeFactOrPattern(t))).filter(t=>t.hasVars());if(e.length>0)throw console.error("the following evidence has vars:"),e.forEach(t=>console.info(t.toString())),new Error("evidence facts cannot have vars!");const r=t.filter(t=>!this._factMap.has(t.toString()));if(r.length>0)throw console.error("the following evidence is not in the database:"),r.forEach(t=>console.info(t.toString())),new Error("evidence facts must be in the database!");n.evidence=t}}}_retract(t,...e){const r=this._makeFactOrPattern(t,...e);if(r.hasVars()){const t=[];for(let e of this.facts)r.match(e,Object.create(null))&&t.push(e);for(let e of t)this._factMap.delete(e.toString());return t.length}return this._factMap.delete(r.toString())?1:0}_retractEverythingAbout(t){const e=this.parse(t,"identity"),r=[],n=Object.create(null);for(let t of this.facts)t.terms.some(t=>e.match(t,n))&&r.push(t);for(let t of r)this._factMap.delete(t.toString());return r.length}_retractEverythingAssertedBy(t){const e=this.facts.filter(e=>e.asserter===t);for(let t of e)this._factMap.delete(t.toString());return e.length}_makeFactOrPattern(t,...e){if(0===arguments.length)throw new Error("_makeFactOrPattern requires at least one argument!");if("string"!=typeof t)throw new Error("factString must be a string!");const r=this.parse(t);for(let t=0;t<r.terms.length;t++){if(r.terms[t]instanceof s){if(0===e.length)throw new Error("not enough filler values!");r.terms[t]=this.toTerm(e.shift())}}if(e.length>0)throw new Error("too many filler values!");return r}parse(t,e="factOrPattern"){if("factOrPattern"!==e)return u.parse(t,e);let r;return this._parseCache.has(t)?r=this._parseCache.get(t):(r=u.parse(t,e),this._parseCache.set(t,r)),r.clone()}clearParseCache(){this._parseCache.clear()}toTerm(n){return n instanceof t?n:"boolean"==typeof n||"string"==typeof n||"number"==typeof n?new e(n):new r(n)}get facts(){return Array.from(this._factMap.values())}toString(){return this.facts.map(t=>t.toString()).join("\n")}}class f{constructor(t,e){this._id=t,this._db=e}select(...t){return this._db._select(...t)}assert(t,...e){return this._db._assert(this._id,t,...e)}retract(t,...e){return this._db._retract(t,...e)}retractEverythingAbout(t){return this._db._retractEverythingAbout(t)}retractEverythingAssertedByMe(){return this._db._retractEverythingAssertedBy(this._id)}get facts(){return this._db.facts}get id(){return this._id}disconnect(){this._db._clientMap.delete(this._id),this._db=null}toString(){return`[client ${this._id}]`}}return u});
//# sourceMappingURL=roomdb.min.js.map
