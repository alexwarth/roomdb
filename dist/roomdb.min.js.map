{"version":3,"file":"roomdb.min.js","sources":["../src/semantics.js","../src/parser.js","../src/RoomDB.js"],"sourcesContent":[" class Term {\n   toRawValue () {\n     return this\n   }\n}\n\n class Val extends Term {\n   constructor (value) {\n     super()\n     this.value = value\n   }\n\n   match (that, env) {\n     return that instanceof Val && this.value === that.value\n        ? env\n        : null\n   }\n\n   toRawValue () {\n     return this.value\n   }\n\n   toString () {\n     return JSON.stringify(this.value)\n   }\n}\n\n class Blob extends Term {\n   constructor (value) {\n     super()\n     this.value = value\n   }\n\n   match (that, env) {\n     return that instanceof Blob && this.value === that.value\n        ? env\n        : null\n   }\n\n   toRawValue () {\n     return this.value\n   }\n\n   toString () {\n     return '@'\n   }\n}\n\n class Var extends Term {\n   constructor (name) {\n     super()\n     this.name = name\n   }\n\n   match (that, env) {\n     if (env[this.name] === undefined) {\n       env[this.name] = that\n       return env\n     } else {\n       return env[this.name].match(that, env)\n     }\n   }\n\n   toRawValue () {\n     throw new Error('vars should never show up in a solution!')\n   }\n\n   toString () {\n     return '$' + this.name\n   }\n}\n\n class Hole extends Term {\n   match (that, env) {\n     throw new Error('holes should never show up in a query pattern')\n   }\n\n   toRawValue () {\n     throw new Error('holes should never show up in a solution!')\n   }\n\n   toString () {\n     return '_'\n   }\n}\n\n class Id extends Term {\n   constructor (name) {\n     super()\n     this.name = name\n   }\n\n   match (that, env) {\n     return that instanceof Id && this.name === that.name\n        ? env\n        : null\n   }\n\n   toString () {\n     return '#' + this.name\n   }\n}\n\n class Word extends Term {\n   constructor (str) {\n     super()\n     this.str = str\n   }\n\n   match (that, env) {\n     return that instanceof Word && this.str === that.str\n        ? env\n        : null\n   }\n\n   toString () {\n     return this.str\n   }\n}\n\n class Fact {\n   constructor (terms) {\n     this.terms = terms\n   }\n\n   hasVars () {\n     return this.terms.some(term => term instanceof Var)\n   }\n\n   match (that, env) {\n     if (this.terms.length !== that.terms.length) {\n       return null\n     }\n     for (let idx = 0; idx < this.terms.length; idx++) {\n       const thisTerm = this.terms[idx]\n       const thatTerm = that.terms[idx]\n       if (!thisTerm.match(thatTerm, env)) {\n         return null\n       }\n     }\n     return env\n   }\n\n   toString () {\n     return this.terms.map(term => term.toString()).join('')\n   }\n\n   clone () {\n     return new Fact(this.terms.slice())\n   }\n}\n\n export { Fact, Word, Term, Blob, Val, Var, Hole, Id }\n","'use strict'\n\nimport { Fact, Val, Var, Hole, Id, Word } from './semantics.js'\n\nconst ohm = require('ohm-js')\n\nconst grammar = ohm.grammar(`\n  G {\n\n    factOrPattern\n      = term*\n\n    term\n      = keyword<\"true\">   -- true\n      | keyword<\"false\">  -- false\n      | keyword<\"null\">   -- null\n      | space+            -- spaces\n      | var\n      | hole\n      | identity\n      | number\n      | string\n      | word\n\n    keyword<k>\n      = k ~alnum\n\n    var\n      = \"$\" alnum*\n\n    hole\n      = \"_\"\n\n    identity\n      = \"#\" alnum*\n\n    number\n      = float (\"e\" float)?\n\n    float\n      = integer (\".\" digit+)?\n\n    integer\n      = (\"+\" | \"-\")? digit+\n\n    string\n      = \"\\\\\"\" (~\"\\\\\"\" ~\"\\\\n\" any)* \"\\\\\"\"\n\n    word\n      = (~special any)+\n\n    special\n      = var | hole | identity | number | space\n\n  }\n`)\n\nconst semantics = grammar\n  .createSemantics()\n  .addOperation('parse', {\n    factOrPattern (terms) {\n      return new Fact(terms.parse())\n    },\n    term_true (_) {\n      return new Val(true)\n    },\n    term_false (_) {\n      return new Val(false)\n    },\n    term_null (_) {\n      return new Val(null)\n    },\n    var (_, cs) {\n      return new Var(cs.sourceString)\n    },\n    hole (_) {\n      return new Hole()\n    },\n    identity (_, cs) {\n      return new Id(cs.sourceString)\n    },\n    number (_1, _2, _3) {\n      return new Val(parseFloat(this.sourceString))\n    },\n    string (_oq, cs, _cq) {\n      const chars = []\n      let idx = 0\n      cs = cs.parse()\n      while (idx < cs.length) {\n        let c = cs[idx++]\n        if (c === '\\\\' && idx < cs.length) {\n          c = cs[idx++]\n          switch (c) {\n            case 'n': c = '\\n'; break\n            case 't': c = '\\t'; break\n            default: idx--\n          }\n        }\n        chars.push(c)\n      }\n      return new Val(chars.join(''))\n    },\n    word (_) {\n      return new Word(this.sourceString)\n    },\n    term_spaces (_) {\n      return new Word(' ')\n    },\n    _terminal () {\n      return this.sourceString\n    }\n  })\n\nexport default function parse (str, rule) {\n  const match = grammar.match(str.trim(), rule)\n\n  if (match.failed()) throw new Error(`invalid ${rule}: ${str}`)\n\n  return semantics(match).parse()\n}\n","'use strict'\n\n// TODO: include \"world time\" in facts\n\n// TODO: think about support for wishes\n\n// TODO: consider space-insensitive matching for facts\n// (would need a canonical representation to use as keys for factMap)\n\n// TODO: think about \"primary keys\"\n\nimport parse from './parser.js'\nimport { Blob, Hole, Term, Val } from './semantics.js'\n\nexport default class RoomDB {\n  constructor () {\n    this._parseCache = new Map()\n    this._factMap = new Map()\n    this._nextClientId = 1\n    this._clientMap = new Map()\n    this.parse = parse\n  }\n\n  connect (id) {\n    if (id === null) id = this._newClientId()\n    if (this._clientMap.has(id)) {\n      throw new Error('there is already a client whose id is ' + id)\n    }\n    const client = new Client(id, this)\n    this._clientMap.set(id, client)\n    return client\n  }\n\n  _newClientId () {\n    return '_' + this._nextClientId++\n  }\n\n  _select (...patterns) {\n    patterns = patterns.map(pattern =>\n        pattern instanceof Array\n            ? this._makeFactOrPattern(...pattern)\n            : this._makeFactOrPattern(pattern))\n    const solutions = []\n    this._collectSolutions(patterns, Object.create(null), solutions)\n    return {\n      do (callbackFn) {\n        for (let solution of solutions) {\n          for (let name in solution) {\n            solution[name] = solution[name].toRawValue()\n          }\n          callbackFn(solution)\n        }\n      },\n      doAll (callbackFn) {\n        let cleanSolutions = []\n        this.do(solution => cleanSolutions.push(solution))\n        callbackFn(cleanSolutions)\n      },\n      count () {\n        return solutions.length\n      },\n      isEmpty () {\n        return solutions.length === 0\n      },\n      isNotEmpty () {\n        return solutions.length > 0\n      }\n    }\n  }\n\n  _collectSolutions (patterns, env, solutions) {\n    if (patterns.length === 0) {\n      solutions.push(env)\n    } else {\n      const pattern = patterns[0]\n      for (let fact of this.facts) {\n        const newEnv = Object.create(env)\n        if (pattern.match(fact, newEnv)) {\n          this._collectSolutions(patterns.slice(1), newEnv, solutions)\n        }\n      }\n    }\n  }\n\n  _assert (asserterClientId, factString, ...fillerValues) {\n    const fact = this._makeFactOrPattern(factString, ...fillerValues)\n    fact.asserter = asserterClientId\n    if (fact.hasVars()) {\n      throw new Error('cannot assert a fact that has vars!')\n    }\n    fact.evidence = []\n    this._factMap.set(fact.toString(), fact)\n    return {\n      withEvidence: (...evidence) => {\n        evidence = evidence.map(e => this._makeFactOrPattern(e))\n        const evidenceWithVars = evidence.filter(e => e.hasVars())\n        if (evidenceWithVars.length > 0) {\n          console.error('the following evidence has vars:')\n          evidenceWithVars.forEach(e => console.info(e.toString()))\n          throw new Error('evidence facts cannot have vars!')\n        }\n        const falseEvidence = evidence.filter(e => !this._factMap.has(e.toString()))\n        if (falseEvidence.length > 0) {\n          console.error('the following evidence is not in the database:')\n          falseEvidence.forEach(e => console.info(e.toString()))\n          throw new Error('evidence facts must be in the database!')\n        }\n        fact.evidence = evidence\n      }\n    }\n  }\n\n  _retract (factString, ...fillerValues) {\n    const factOrPattern = this._makeFactOrPattern(factString, ...fillerValues)\n    if (factOrPattern.hasVars()) {\n      const factsToRetract = []\n      for (let fact of this.facts) {\n        if (factOrPattern.match(fact, Object.create(null))) {\n          factsToRetract.push(fact)\n        }\n      }\n      for (let fact of factsToRetract) {\n        this._factMap.delete(fact.toString())\n      }\n      return factsToRetract.length\n    } else {\n      return this._factMap.delete(factOrPattern.toString()) ? 1 : 0\n    }\n  }\n\n  _retractEverythingAbout (idString) {\n    const id = this.parse(idString, 'identity')\n    const factsToRetract = []\n    const emptyEnv = Object.create(null)\n    for (let fact of this.facts) {\n      if (fact.terms.some(term => id.match(term, emptyEnv))) {\n        factsToRetract.push(fact)\n      }\n    }\n    for (let fact of factsToRetract) {\n      this._factMap.delete(fact.toString())\n    }\n    return factsToRetract.length\n  }\n\n  _retractEverythingAssertedBy (clientId) {\n    const factsToRetract = this.facts.filter(fact => fact.asserter === clientId)\n    for (let fact of factsToRetract) {\n      this._factMap.delete(fact.toString())\n    }\n    return factsToRetract.length\n  }\n\n  _makeFactOrPattern (factString, ...fillerValues) {\n    if (arguments.length === 0) {\n      throw new Error('_makeFactOrPattern requires at least one argument!')\n    }\n    if (typeof factString !== 'string') {\n      throw new Error('factString must be a string!')\n    }\n    const fact = this.parse(factString)\n    for (let idx = 0; idx < fact.terms.length; idx++) {\n      const term = fact.terms[idx]\n      if (term instanceof Hole) {\n        if (fillerValues.length === 0) {\n          throw new Error('not enough filler values!')\n        }\n        fact.terms[idx] = this.toTerm(fillerValues.shift())\n      }\n    }\n    if (fillerValues.length > 0) {\n      throw new Error('too many filler values!')\n    }\n    return fact\n  }\n\n  parse (str, rule = 'factOrPattern') {\n    if (rule !== 'factOrPattern') {\n      return RoomDB.parse(str, rule)\n    }\n    let thing\n    if (this._parseCache.has(str)) {\n      thing = this._parseCache.get(str)\n    } else {\n      thing = RoomDB.parse(str, rule)\n      this._parseCache.set(str, thing)\n    }\n    return thing.clone()\n  }\n\n  clearParseCache () {\n    this._parseCache.clear()\n  }\n\n  toTerm (x) {\n    if (x instanceof Term) {\n      return x\n    } else if (typeof x === 'boolean' ||\n               typeof x === 'string' ||\n               typeof x === 'number') {\n      return new Val(x)\n    } else {\n      return new Blob(x)\n    }\n  }\n\n  get facts () {\n    return Array.from(this._factMap.values())\n  }\n\n  toString () {\n    return this.facts.map(fact => fact.toString()).join('\\n')\n  }\n}\n\nclass Client {\n  constructor (id, db) {\n    this._id = id\n    this._db = db\n  }\n\n  select (...patterns) {\n    return this._db._select(...patterns)\n  }\n\n  assert (factString, ...fillerValues) {\n    return this._db._assert(this._id, factString, ...fillerValues)\n  }\n\n  retract (factString, ...fillerNames) {\n    return this._db._retract(factString, ...fillerNames)\n  }\n\n  retractEverythingAbout (idString) {\n    return this._db._retractEverythingAbout(idString)\n  }\n\n  retractEverythingAssertedByMe () {\n    return this._db._retractEverythingAssertedBy(this._id)\n  }\n\n  get facts () {\n    return this._db.facts\n  }\n\n  get id () {\n    return this._id\n  }\n\n  disconnect () {\n    this._db._clientMap.delete(this._id)\n    this._db = null  // to disable this client\n  }\n\n  toString () {\n    return `[client ${this._id}]`\n  }\n}\n"],"names":["Term","[object Object]","this","Val","value","super","that","env","JSON","stringify","Blob","Var","name","undefined","match","Error","Hole","Id","Word","str","Fact","terms","some","term","length","idx","thisTerm","thatTerm","map","toString","join","slice","grammar","require","semantics","createSemantics","addOperation","factOrPattern","parse","term_true","_","term_false","term_null","var","cs","sourceString","hole","identity","_1","_2","_3","parseFloat","_oq","_cq","chars","c","push","term_spaces","rule","trim","failed","RoomDB","_parseCache","Map","_factMap","_nextClientId","_clientMap","id","_newClientId","has","client","Client","set","patterns","pattern","Array","_makeFactOrPattern","solutions","_collectSolutions","Object","create","callbackFn","solution","toRawValue","cleanSolutions","do","count","isEmpty","isNotEmpty","fact","facts","newEnv","asserterClientId","factString","fillerValues","asserter","hasVars","evidence","withEvidence","evidenceWithVars","e","filter","console","error","forEach","info","falseEvidence","factsToRetract","delete","idString","emptyEnv","clientId","arguments","toTerm","shift","thing","get","clone","clear","x","from","values","db","_id","_db","_select","_assert","fillerNames","_retract","_retractEverythingAbout","_retractEverythingAssertedBy"],"mappings":"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"}