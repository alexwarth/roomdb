!function(t,e){"object"==typeof exports&&"undefined"!=typeof module?module.exports=e():"function"==typeof define&&define.amd?define(e):t.roomdb=e()}(this,function(){"use strict";const t=require("ohm-js").grammar('\n  G {\n\n    factOrPattern\n      = term*\n\n    term\n      = id\n      | word\n      | value\n      | variable\n      | wildcard\n      | hole\n\n    id\n      = "#" alnum*\n\n    value\n      = keyword<"true">   -- true\n      | keyword<"false">  -- false\n      | keyword<"null">   -- null\n      | number\n      | string\n\n    variable\n      = "$" alnum+\n\n    wildcard\n      = "$"\n\n    hole\n      = "_"\n\n    word\n      = (~special any)+  -- nonspace\n      | space+           -- space\n\n    keyword<k>\n      = k ~alnum\n\n    number\n      = float ("e" float)?\n\n    float\n      = integer ("." digit+)?\n\n    integer\n      = ("+" | "-")? digit+\n\n    string\n      = "\\"" (~"\\"" ~"\\n" any)* "\\""\n\n    special\n      = id | value | variable | wildcard | hole | space\n\n  }\n'),e=t.createSemantics().addOperation("parse",{factOrPattern:t=>t.parse(),id:(t,e)=>({id:e.sourceString}),value_true:t=>({value:!0}),value_false:t=>({value:!1}),value_null:t=>({value:null}),variable:(t,e)=>({variable:e.sourceString}),wildcard:t=>({wildcard:!0}),hole:t=>({hole:!0}),word_nonspace(t){return{word:this.sourceString}},word_space:t=>({word:" "}),number(t,e,r){return{value:parseFloat(this.sourceString)}},string(t,e,r){const s=[];let n=0;for(e=e.parse();n<e.length;){let t=e[n++];if("\\"===t&&n<e.length)switch(t=e[n++]){case"n":t="\n";break;case"t":t="\t";break;default:n--}s.push(t)}return{value:s.join("")}},_terminal(){return this.sourceString}});const r=1e3;class s{constructor(t){this._id=t,this._parseCache=new Map,this._asserts=[],this._retracts=[]}assert(t,...e){const r=this._toJSONFactOrPattern(t,...e);this._asserts.push(r)}retract(t,...e){const r=this._toJSONFactOrPattern(t,...e);this._retracts.push(r)}async flushChanges(){throw new Error("subclass responsibility")}async immediatelyAssert(t,...e){this.assert(t,...e),await this.flushChanges()}async immediatelyRetract(t,...e){this.assert(t,...e),await this.flushChanges()}async immediatelyRetractEverythingAbout(t){throw new Error("subclass responsibility")}async immediatelyRetractEverythingAssertedByMe(){throw new Error("subclass responsibility")}async getAllFacts(){throw new Error("subclass responsibility")}_toJSONFactOrPattern(t,...e){if(0===arguments.length)throw new Error("not enough arguments!");if("string"!=typeof t)throw new Error("factOrPatternString must be a string!");let r=this._parse(t);e.length>0&&(r=r.slice());for(let t=0;t<r.length;t++){if(r[t].hasOwnProperty("hole")){if(0===e.length)throw new Error("not enough filler values!");r[t]=this._toJSONTerm(e.shift())}}if(e.length>0)throw new Error("too many filler values!");return r}_toJSONTerm(t){return{value:t}}_parse(r){if(this._parseCache.has(r))return this._parseCache.get(r);{this._clearParseCacheIfTooBig();const s=function(r,s){const n=s||"factOrPattern",a=t.match(r.trim(),n);if(a.succeeded())return e(a).parse();throw new Error(`invalid ${n}: ${r}`)}(r);return this._parseCache.set(r,s),s}}_clearParseCacheIfTooBig(){this._parseCache.size>r&&this.clearParseCache()}clearParseCache(){this._parseCache.clear()}}class n{toString(){throw new Error("subclass responsibility")}toJSON(){throw new Error("subclass responsibility")}toRawValue(){throw new Error("subclass responsibility")}match(t,e){throw new Error("subclass responsibility")}}n.fromJSON=(t=>{if(t.hasOwnProperty("id"))return new a(t.id);if(t.hasOwnProperty("word"))return new i(t.word);if(t.hasOwnProperty("value"))return new o(t.value);if(t.hasOwnProperty("blobRef"))return new l(t.blobRef);if(t.hasOwnProperty("variable"))return new c(t.variable);if(t.hasOwnProperty("wildcard"))return new h;if(t.hasOwnProperty("hole"))return new class extends n{constructor(){super()}toString(){return"_"}toJSON(){return{hole:!0}}toRawValue(){throw new Error("Hole's toRawValue() should never be called!")}match(t,e){throw new Error("Hole's match() should never be called!")}};throw new Error("unrecognized JSON term: "+JSON.stringify(t))});class a extends n{constructor(t){super(),this.name=t}toString(){return"#"+this.name}toJSON(){return{id:this.name}}toRawValue(){return this}match(t,e){return t instanceof a&&this.name===t.name?e:null}}class i extends n{constructor(t){super(),this.value=t}toString(){return this.value}toJSON(){return{word:this.value}}toRawValue(){return this}match(t,e){return t instanceof i&&this.value===t.value?e:null}}class o extends n{constructor(t){super(),this.value=t}toString(){return JSON.stringify(this.value)}toJSON(){return{value:this.value}}toRawValue(){return this.value}match(t,e){return t instanceof o&&this.value===t.value?e:null}}class l extends n{constructor(t){super(),this.id=t}toString(){return"@"+this.id}toJSON(){return{blobRef:this.id}}toRawValue(){return this}match(t,e){return t instanceof l&&this.id===t.id?e:null}}class c extends n{constructor(t){super(),this.name=t}toString(){return"$"+this.name}toJSON(){return{variable:this.name}}toRawValue(){throw new Error("Variable's toRawValue() should never be called!")}match(t,e){return void 0===e[this.name]?(e[this.name]=t,e):e[this.name].match(t,e)}}class h extends n{constructor(){super()}toString(){return"$"}toJSON(){return{wildcard:!0}}toRawValue(){throw new Error("Wildcard's toRawValue() should never be called!")}match(t,e){return e}}class u extends s{constructor(t,e){super(e),this._db=t}select(...t){const e=t.map(t=>t instanceof Array?this._toJSONFactOrPattern(...t):this._toJSONFactOrPattern(t)),r=this._db.select(...e),s={async do(t){for(let e of r){for(let t in e){const r=JSON.parse(JSON.stringify(e[t]));e[t]=n.fromJSON(r).toRawValue()}await t(e)}return s},count:async()=>r.length,isEmpty:async()=>0===r.length,isNotEmpty:async()=>r.length>0};return s}async flushChanges(){this._retracts.forEach(t=>this._db.retract(this._id,t)),this._retracts=[],this._asserts.forEach(t=>this._db.assert(this._id,t)),this._asserts=[]}async immediatelyRetractEverythingAbout(t){return this._db.retractEverythingAbout(this._id,t)}async immediatelyRetractEverythingAssertedByMe(){return this._db.retractEverythingAssertedBy(this._id)}async getAllFacts(){return this._db.getAllFacts()}toString(){return`[LocalClient ${this._id}]`}}class d{constructor(t){this.terms=t}hasVariablesOrWildcards(){return this.terms.some(t=>t instanceof c||t instanceof h)}match(t,e){if(this.terms.length!==t.terms.length)return null;for(let r=0;r<this.terms.length;r++){const s=this.terms[r],n=t.terms[r];if(!s.match(n,e))return null}return e}toString(){return this.terms.map(t=>t.toString()).join("")}}function f(t){for(let e in t)t[e]=t[e];return t}d.fromJSON=(t=>new d(t.map(t=>n.fromJSON(t))));return class{constructor(){this._factMap=new Map}select(...t){const e=t.map(t=>d.fromJSON(t)),r=[];return this._collectSolutions(e,Object.create(null),r),r.map(f)}_collectSolutions(t,e,r){if(0===t.length)r.push(e);else{const s=t[0];for(let n of this._facts){const a=Object.create(e);s.match(n,a)&&this._collectSolutions(t.slice(1),a,r)}}}assert(t,e){const r=d.fromJSON(e);if(r.hasVariablesOrWildcards())throw new Error("cannot assert a fact that has variables or wildcards!");r.asserter=t,this._factMap.set(r.toString(),r)}retract(t,e){const r=d.fromJSON(e);if(r.hasVariablesOrWildcards()){const t=this._facts.filter(t=>r.match(t,Object.create(null)));return t.forEach(t=>this._factMap.delete(t.toString())),t.length}return this._factMap.delete(r.toString())?1:0}retractEverythingAbout(t,e){const r=new a(e),s=Object.create(null),n=this._facts.filter(t=>t.terms.some(t=>r.match(t,s)));return n.forEach(t=>this._factMap.delete(t.toString())),n.length}retractEverythingAssertedBy(t){const e=this._facts.filter(e=>e.asserter===t);return e.forEach(t=>this._factMap.delete(t.toString())),e.length}get _facts(){return Array.from(this._factMap.values())}getAllFacts(){return this._facts.map(t=>t.toString())}toString(){return this._facts.map(t=>"<"+t.asserter+"> "+t.toString()).join("\n")}client(t="local-client"){return new u(this,t)}}});
//# sourceMappingURL=roomdb.min.js.map
